{
  "name": "Book Appointment",
  "nodes": [
    {
      "parameters": {
        "path": "book",
        "httpMethod": "POST",
        "options": {}
      },
      "id": "webhook-book",
      "name": "Webhook - Book Appointment",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [240, 300],
      "webhookId": "book-appointment",
      "description": "Receives appointment booking requests from backend API"
    },
    {
      "parameters": {
        "jsCode": "// Validate incoming booking data\nconst data = $input.item.json.body;\nconst errors = [];\n\n// Required fields validation\nif (!data.name || typeof data.name !== 'string' || data.name.trim() === '') {\n  errors.push('Name is required and must be a non-empty string');\n}\n\nif (!data.email || typeof data.email !== 'string') {\n  errors.push('Email is required');\n} else {\n  // Basic email validation\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  if (!emailRegex.test(data.email)) {\n    errors.push('Email must be in valid format');\n  }\n}\n\nif (!data.date || typeof data.date !== 'string') {\n  errors.push('Date is required');\n} else {\n  // Date format validation (YYYY-MM-DD)\n  const dateRegex = /^\\d{4}-\\d{2}-\\d{2}$/;\n  if (!dateRegex.test(data.date)) {\n    errors.push('Date must be in YYYY-MM-DD format');\n  } else {\n    const appointmentDate = new Date(data.date);\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    if (appointmentDate < today) {\n      errors.push('Date cannot be in the past');\n    }\n  }\n}\n\nif (!data.time || typeof data.time !== 'string') {\n  errors.push('Time is required');\n} else {\n  // Time format validation (HH:MM)\n  const timeRegex = /^([0-1][0-9]|2[0-3]):[0-5][0-9]$/;\n  if (!timeRegex.test(data.time)) {\n    errors.push('Time must be in HH:MM format (24-hour)');\n  }\n}\n\nif (!data.reason || typeof data.reason !== 'string' || data.reason.trim() === '') {\n  errors.push('Reason is required and must be a non-empty string');\n}\n\n// Return validation result\nif (errors.length > 0) {\n  return {\n    json: {\n      valid: false,\n      errors: errors,\n      originalData: data\n    }\n  };\n}\n\n// Normalize data\nreturn {\n  json: {\n    valid: true,\n    data: {\n      name: data.name.trim(),\n      email: data.email.toLowerCase().trim(),\n      date: data.date,\n      time: data.time,\n      reason: data.reason.trim()\n    },\n    requestId: $execution.id,\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      "id": "validate-booking",
      "name": "Validate Booking Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300],
      "description": "Validates incoming booking data (name, email, date, time, reason)"
    },
    {
      "parameters": {
        "jsCode": "// Log booking request for debugging\nconst item = $input.item.json;\nconst logEntry = {\n  timestamp: new Date().toISOString(),\n  requestId: item.requestId || $execution.id,\n  type: 'booking_request',\n  valid: item.valid,\n  data: item.data || item.originalData,\n  errors: item.errors || null\n};\n\n// Log to console (visible in n8n execution logs)\nconsole.log('Booking Request Log:', JSON.stringify(logEntry, null, 2));\n\n// Return data for next node\nreturn item;"
      },
      "id": "log-booking",
      "name": "Log Booking Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 300],
      "description": "Logs booking request with timestamp and request ID for debugging"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.valid }}",
              "value2": true
            }
          ]
        }
      },
      "id": "check-validation",
      "name": "Check Validation",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [900, 300],
      "description": "Routes workflow based on validation result"
    },
    {
      "parameters": {
        "jsCode": "// Prepare Google Calendar event data\nconst bookingData = $input.item.json.data;\nconst requestId = $input.item.json.requestId;\n\n// Calculate start and end times (1-hour default duration)\nconst startDateTime = new Date(`${bookingData.date}T${bookingData.time}:00`);\nconst endDateTime = new Date(startDateTime.getTime() + 60 * 60 * 1000); // Add 1 hour\n\n// Format dates for Google Calendar API (RFC3339 format)\nconst formatDateTime = (date) => {\n  return date.toISOString().replace(/\\.\\d{3}/, '');\n};\n\n// Don't set calendarId - let the backend use GOOGLE_CALENDAR_ID from its environment\n// This centralizes calendar ID configuration in the backend .env file\n// No need to set it here since backend will use its env var if calendarId is not provided\n\n// Prepare event data\n// Note: Service accounts cannot invite attendees, so email is included in description only\nconst eventData = {\n  summary: `Appointment: ${bookingData.name}`,\n  description: `Reason: ${bookingData.reason} | Email: ${bookingData.email}`,\n  start: {\n    dateTime: formatDateTime(startDateTime),\n    timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC'\n  },\n  end: {\n    dateTime: formatDateTime(endDateTime),\n    timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC'\n  }\n};\n\n// Log event preparation\nconsole.log('Preparing Google Calendar Event:', JSON.stringify({\n  timestamp: new Date().toISOString(),\n  requestId: requestId,\n  note: 'Calendar ID will be determined by backend from GOOGLE_CALENDAR_ID env var',\n  eventData: eventData\n}, null, 2));\n\nreturn {\n  json: {\n    ...$input.item.json,\n    eventData: eventData\n    // Note: calendarId not included - backend will use GOOGLE_CALENDAR_ID from its .env\n  }\n};"
      },
      "id": "prepare-calendar-event",
      "name": "Prepare Calendar Event",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 200],
      "description": "Prepares Google Calendar event data with proper date/time formatting"
    },
    {
      "parameters": {
        "url": "http://chatbot-backend:3000/api/google-calendar/create",
        "authentication": "none",
        "method": "POST",
        "sendBody": true,
        "contentType": "json",
        "specifyBody": "json",
        "jsonBody": "={{ { eventData: $json.eventData } }}",
        "options": {}
      },
      "id": "google-calendar-create",
      "name": "Google Calendar - Create Event",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1340, 200],
      "description": "Creates event in Google Calendar via backend API (which handles JWT authentication)"
    },
    {
      "parameters": {
        "jsCode": "// Parse backend response and format for next node\nconst response = $input.item.json;\n\n// Try to find booking data from the input chain (from before HTTP request)\n// HTTP Request nodes in n8n preserve previous input items in $input.all()\nlet bookingData = null;\nlet requestId = null;\n\n// Check all input items to find the one with booking data\n// The HTTP response will be the first item, so we need to check all items\nfor (let i = 0; i < $input.all().length; i++) {\n  const item = $input.all()[i];\n  \n  // Skip the HTTP response itself (usually first item)\n  if (item.json.success !== undefined && item.json.event) {\n    continue;\n  }\n  \n  // Look for booking data in various possible locations\n  if (item.json && item.json.data && item.json.data.name) {\n    bookingData = item.json.data;\n    requestId = item.json.requestId || $execution.id;\n    break;\n  }\n  \n  // Also check if bookingData is directly on the item\n  if (item.json && item.json.bookingData) {\n    bookingData = item.json.bookingData;\n    requestId = item.json.requestId || $execution.id;\n    break;\n  }\n}\n\nif (!response.success || !response.event) {\n  throw new Error(response.error || 'Failed to create calendar event');\n}\n\nconst event = response.event;\n\n// If we still don't have booking data, try to extract from event summary/description\nif (!bookingData && event.summary && event.description) {\n  const summaryMatch = event.summary.match(/Appointment: (.+)/);\n  const emailMatch = event.description.match(/Email: ([^|\\s]+)/);\n  const reasonMatch = event.description.match(/Reason: ([^|]+)/);\n  \n  bookingData = {\n    name: summaryMatch ? summaryMatch[1] : 'Unknown',\n    email: emailMatch ? emailMatch[1].trim() : 'unknown@example.com',\n    date: event.start ? event.start.dateTime?.split('T')[0] : 'unknown',\n    time: event.start ? event.start.dateTime?.split('T')[1]?.substring(0, 5) : 'unknown',\n    reason: reasonMatch ? reasonMatch[1].trim() : 'N/A'\n  };\n}\n\nconsole.log('Google Calendar Event Created Successfully:', JSON.stringify({\n  timestamp: new Date().toISOString(),\n  requestId: requestId || $execution.id,\n  eventId: event.id,\n  eventLink: event.htmlLink,\n  hasBookingData: !!bookingData\n}, null, 2));\n\n// Return formatted response with booking data and request ID for next nodes\nreturn {\n  json: {\n    id: event.id,\n    htmlLink: event.htmlLink,\n    summary: event.summary,\n    start: event.start,\n    end: event.end,\n    bookingData: bookingData,\n    requestId: requestId || $execution.id\n  }\n};"
      },
      "id": "parse-calendar-response",
      "name": "Parse Calendar Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1560, 200],
      "description": "Parses backend response and formats for next node"
    },
    {
      "parameters": {
        "jsCode": "// Log successful calendar event creation and format response\nconst calendarResponse = $input.item.json;\n\n// Try to get booking data from calendar response first\nlet bookingData = calendarResponse.bookingData;\nlet requestId = calendarResponse.requestId;\n\n// If not found, try to find it in the input chain\nif (!bookingData) {\n  // Search through all input items to find booking data\n  for (const item of $input.all()) {\n    if (item.json && item.json.data && item.json.data.name) {\n      bookingData = item.json.data;\n      requestId = item.json.requestId || requestId || $execution.id;\n      break;\n    }\n  }\n}\n\n// If still not found, create a minimal booking data object to prevent errors\nif (!bookingData) {\n  console.warn('Booking data not found in calendar response or input chain - using event summary as fallback');\n  bookingData = {\n    name: calendarResponse.summary ? calendarResponse.summary.replace('Appointment: ', '') : 'Unknown',\n    email: 'unknown@example.com',\n    date: calendarResponse.start ? calendarResponse.start.dateTime?.split('T')[0] : 'unknown',\n    time: calendarResponse.start ? calendarResponse.start.dateTime?.split('T')[1]?.substring(0, 5) : 'unknown',\n    reason: 'N/A'\n  };\n}\n\nconst eventId = calendarResponse.id;\nconst eventLink = calendarResponse.htmlLink;\n\n// Log success\nconst logEntry = {\n  timestamp: new Date().toISOString(),\n  requestId: requestId || $execution.id,\n  type: 'calendar_event_created',\n  success: true,\n  eventId: eventId,\n  eventLink: eventLink,\n  bookingData: {\n    name: bookingData.name || 'Unknown',\n    email: bookingData.email || 'unknown@example.com',\n    date: bookingData.date || 'unknown',\n    time: bookingData.time || 'unknown',\n    reason: bookingData.reason || 'N/A'\n  }\n};\n\nconsole.log('Google Calendar Event Created Successfully:', JSON.stringify(logEntry, null, 2));\n\n// Return formatted response\nreturn {\n  json: {\n    success: true,\n    message: 'Appointment booking processed successfully',\n    eventId: eventId,\n    eventLink: eventLink,\n    bookingData: bookingData,\n    requestId: requestId || $execution.id\n  }\n};"
      },
      "id": "log-calendar-success",
      "name": "Log Calendar Success",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1780, 200],
      "description": "Logs successful calendar event creation with event ID and details"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "respond-success",
      "name": "Respond - Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2000, 200],
      "description": "Sends success response back to backend API"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"success\": false, \"error\": \"Validation Error\", \"details\": $json.errors, \"message\": \"Invalid booking data provided\" } }}",
        "options": {
          "responseCode": 400
        }
      },
      "id": "respond-error",
      "name": "Respond - Validation Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1120, 400],
      "description": "Sends validation error response back to backend API"
    }
  ],
  "connections": {
    "Webhook - Book Appointment": {
      "main": [[{ "node": "Validate Booking Data", "type": "main", "index": 0 }]]
    },
    "Validate Booking Data": {
      "main": [[{ "node": "Log Booking Request", "type": "main", "index": 0 }]]
    },
    "Log Booking Request": {
      "main": [[{ "node": "Check Validation", "type": "main", "index": 0 }]]
    },
    "Check Validation": {
      "main": [
        [{ "node": "Prepare Calendar Event", "type": "main", "index": 0 }],
        [{ "node": "Respond - Validation Error", "type": "main", "index": 0 }]
      ]
    },
    "Prepare Calendar Event": {
      "main": [[{ "node": "Google Calendar - Create Event", "type": "main", "index": 0 }]]
    },
    "Google Calendar - Create Event": {
      "main": [[{ "node": "Parse Calendar Response", "type": "main", "index": 0 }]]
    },
    "Parse Calendar Response": {
      "main": [[{ "node": "Log Calendar Success", "type": "main", "index": 0 }]]
    },
    "Log Calendar Success": {
      "main": [[{ "node": "Respond - Success", "type": "main", "index": 0 }]]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2026-01-14T20:00:00.000Z",
  "versionId": "1"
}
